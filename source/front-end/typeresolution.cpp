#include "../headers/util.h"
#include "../headers/ast.h"
#include "../headers/typeresolution.h"
#include "../headers/errorlogger.h"
#include "../headers/symboltable.h"
#include "../headers/scope.h"


/* if the types are incompatible, add a new error message to the list of error messages in the error logger. */
void TypeResolution::IncompatibleTypes(YYLTYPE *info, std::string node, std::string name, std::string type1, std::string type2) {
    if(type1 != type2) {
        ErrLog::InsertMsg(ErrLog::IncompatibleTypes(info, node, name, type1, type2));
    }
}

/* If the types of a binary op are incompatible, add new error message to the error logger. */
void TypeResolution::IncompatibleTypesBinOp(YYLTYPE *info, std::string name, Expression *exprLhs, Expression *exprRhs) {
    if(exprLhs->getType() != exprRhs->getType()) {
        ErrLog::InsertMsg(ErrLog::IncompatibleTypesBinOps(info, name, exprLhs->getType(), exprRhs->getType()));
    }
}

/* Annotate untyped ID's found within expressions with their correct type. */
void TypeResolution::annotateExpr(Expression *expr) {
    if(UnaryOpExpr *unaryOpExpr = dynamic_cast<UnaryOpExpr*>(expr)) {
        annotateExpr(unaryOpExpr->expr);
        annotateUnaryOp(unaryOpExpr);
    }
    else if(BitwiseOpExpr *binOpExpr = dynamic_cast<BitwiseOpExpr*>(expr)) {
        annotateExpr(binOpExpr->lExpr);
        annotateExpr(binOpExpr->rExpr);
        annotateBinOp(binOpExpr);
    }
    else if(FuncCall *funcCall = dynamic_cast<FuncCall*>(expr)) {
        if(funcCall->params == nullptr) {
            return;
        }

        for(Expression *funcCallArg : *funcCall->params) {
            annotateExpr(funcCallArg);
        }
    }
    else if(Identifier *identifier = dynamic_cast<Identifier*>(expr)) {
        if(identifier->getType() != "") {
            return;
        }

        symTableEntry *entry = Scope::GetSymbol(identifier->name);

        if(entry == nullptr) {
            /* ID's generated by desugaring have no declaration info.
             * Return upon encountering, an error msg has already been generated
             * at this point, since there is no entry in the sym table. */
            if(identifier->info == nullptr) {
                return;
            }
            ErrLog::InsertMsg(ErrLog::UndefinedVar(identifier->info, identifier->name));
            return;
        }

        identifier->type = entry->type;
    }
    else if(expr == nullptr) {
        cout_str("error : TypeResolution::annotateExpr, expr is nullptr");
    }
}

void TypeResolution::annotateBinOp(BitwiseOpExpr *node) {
    std::vector<std::string> arithmeticOps = { "+", "-", "*", "/", "%" };
    std::vector<std::string> boolOps = {"<", ">", "<=", ">=", "!=", "==", "||", "&&"};

    for(const std::string &op : arithmeticOps) {
        if(node->binOp == op) {
            node->type = node->lExpr->getType();
            return;
        }
    }

    for(const std::string &op : boolOps) {
        if(node->binOp == op) {
            node->type = "bool";
            return;
        }
    }

    cout_str("error : TypeResolution::annotateBinOp, could not find given binary op " + node->binOp);
}

void TypeResolution::annotateUnaryOp(UnaryOpExpr *node) {
    if(node->unaryOp == '!') {
        node->type = "bool";
    }
    else if(node->unaryOp == '-') {
        std::string exprType = node->expr->getType();

        /* Only allowed to apply the unary operator - to types int and float. */
        if(exprType == "char" || exprType == "bool") {
            ErrLog::InsertMsg(ErrLog::InvalidNegOpType(node->info, exprType));
        }

        node->type = exprType;
    }
    else {
        cout_str("error : TypeResolution::annotateUnaryOp encountering unary op is not '!' or '-'");
    }
}
